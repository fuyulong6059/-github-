-- -----------------------------------
-- 一、创建建数据库、创建建数据表、查看数据库、查看数据表
-- -----------------------------------
-- 01.查看mysql服务器中所有数据库
	-- 查询当前服务器中的所有库
	show databases; 
结果如下： 
+--------------------+  
+--------------------+
| db10               |
| db20               |
| db30               |
| db40               |
| information_schema |
| mydb1              |
| mydb2              |
| performance_schema |
| test               |
+--------------------+
9 rows in set (0.000 sec)


	
	-- 查询某一个库中所有表
	show tables;
结果如下： 
+----------------+
| Tables_in_db10 |
+----------------+
| emp            |
+----------------+
1 row in set (0.000 sec)








	
-- 02.进入某一数据库（进入数据库后，才能操作库中的表和表记录）
  数据库没有切换数据库指令：可以直接用use 库名字 直接跳转到你想要去的库
	use 库名;
	
结果如下：
MariaDB [db10]> use   db10;
Database changed

可以选择你数据库服务器里已经建好的数据库两个数据库
	
	use mysql;


	
	use test;

	
	-- 查看已进入的库
	select database();
结果如下：
+------------+
| database() |
+------------+
| db10       |
+------------+
1 row in set (0.000 sec)



-- 03.查看当前数据库中的所有表
	show tables;



	
-- 04.删除mydb1库
	-- 语法：drop database 库名;
	drop database mydb1;
	/* 思考：当删除的表不存在时，如何避免错误产生？ */
	drop database if exists mydb1;




	
-- 05.重新创建mydb1库，指定编码为utf8
	-- 语法：create database 库名 charset 编码;
	create database mydb1 charset utf8;
	-- 如果不存在则创建mydb1;
	create database if not exists mydb1 charset utf8;
	     //必须指定utf8不然会乱码可以用 show   create databases 库名；查看建库时的语句；
	     //如果艰苦时，没有指定编码，默认编码是latin1，而latin1中没有文件，所以在存储中文数据时，必然会出现乱码问题，因此需要将库删除重建，重建是，指定编码utf8                                               




	
-- 06.查看建库时的语句（并验证数据库库使用的编码）
	-- 语法：show create database 库名;
	-- 查看建库时的语句
	show create database mydb1;
	-- 查看建表时的语句
	show create table 表名;
	
-- 07.进入mydb1库，删除stu学生表(如果存在)
	-- 语法：drop table 表名;
	use mydb1;
	drop table if exists stu;




-- 08.创建stu学生表（编号[数值类型]、姓名、性别、出生年月、考试成绩[浮点型]）
	/* 建表的语法：
	create table 表名(
		列名 数据类型,
		列名 数据类型,
		...
	); */

 create table emp(
    id  int primary  key auto_increment,
    name  varchar(20),
    gender varchar(2),
    birthday   date,
    job varchar(50),
    salary double,
    bonuse double
     );

	
	use mydb1;//打开 mydb1数据库
	drop table stu;//删除为stu 表
	create table stu(
		id int primary key auto_increment,/*这个auto_increment,表示主键自增*/
		name varchar(50),
		gender varchar(2),
		birthday date,
		score double
	);



-- 09.查看stu学生表结构
	-- 语法：desc 表名;
	desc stu;
	
-- -----------------------------------
-- 二、新增、修改、删除表记录 **********
-- -----------------------------------

-- 10.往学生表(stu)中插入记录(数据) //into；表示列列表(一行上的)  values表示值列表。赋值时要对应
	-- 插入记录：insert into 表名(列1，列2，列3...) values(值1，值2，值3...);
	-- 在插入值时，字符串和日期类型的值，要加上单引号。
	insert into stu(id,name,gender,birthday,score) values(null,'tom','1','1988-3-4',88);

	 //在插入中文指令时一定要先输入命令：set name gbk;然后再插入中文，
	insert into stu values(null,'andy','0','1986-4-5',76);
	insert into stu values(null,'王海涛','男','1992-6-4',60);
	insert into stu values(10000,'刘沛霞','男','1992-5-5',80);
	insert into stu values(null,'韩少云','男','1993-5-5',70);

	/* 提示：
	 设置编码：set names gbk;
	 查看MySQL数据库使用的编码：0
	 mysql --default-character-set=gbk -uroot -proot */



    /* 
    1、主键约束：设置某列为主键约束这列值既不能重复也不能为空。
       给列添加一个主键约束：
    create table  if  not exists stu(
      列名  数据类型 primary  key;
     );


      2、唯一约束：可以为空但是不可以重复。
        给列添加一个唯一约束：
    create table  if  not exists stu(
       列名   数据类型  unique  key;
     );


     3、非空约束：这列值不能为空，但可以重复。
        给列添加一个非空约束：
    create table  if  not exists stu(
         列名   数据类型 not null  key;
     );   
    */
            



 

	 
-- 11.查询stu表所有学生的信息
	select * from stu;        /*   这个*表示统配所有列   */



	
-- 12.修改stu表中所有学生的成绩，加10分特长分
	-- 修改语法: update 表名 set 列=值,列=值,列=值...;
	update stu set score=score+10;
	
	update stu set score+=10;##mysql不支持+=

    /* 只给王海涛加十分update stu set score=score+10  where   name ='王海涛' ； */
    /*这里用了where用来指定选择*/
     /* 只给王海涛减十分update stu set score=score+10  where   name ='王海涛' ； */


	
-- 13.修改stu表中王海涛的成绩，将成绩改为88分。
	update stu set score=88
	where name='王海涛';
	
	/* 提示：where子句用于
	对记录进行筛选过滤，
	   保留符合条件的记录，将不符合条件的记录剔除。*/





-- 14.删除stu表中所有的记录
	-- 删除记录语法: delete from 表名 [where条件] 

	/*drop主要用于删除库以及删除表，和删除表记录没有关系。
	  delete 和truncate都是用于删除表记录。
	  delete删除表记录
	  */

	
	drop database 库名 //这表示删除了整个库
	drop table 表名   //这表示把表删除了
	delete from 表名 where条件。。

	-- 仅删除符合条件的



      //创建一个表名叫stu的表
     create table stu(
		id int primary key auto_increment,

		/*这个auto_increment,表示主键自增，
          insert into stu values(null,'王海涛','男','1992-6-4',60);这个null会在    auto_increment作用下自增变1后续再出现null会变2*/

          
		name varchar(50),
		gender varchar(2),
		birthday date,
		score double
	);
	delete from stu ；这表示删除表,但是它的自增还在
	delete from stu where id=3;
	truncate table  stu ;这也表示删除表，但是它的自增记录不见了
/*
库的创建、删除、修改
表的创建、删除、修改
表记录   增、删、改、查
*/




	
-- -----------------------------------
-- 三、基础查询、where子句查询
-- -----------------------------------
-- 准备数据： 以下练习将使用db10库中的表及表记录，请先进入db10数据库!!!
-- 准备数据： 以下练习将使用db10库中的表及表记录，请先进入db10数据库!!!

语法如下 :
     use   db10;

	
   select * from emp;
 结果如下：
+----+--------+--------+------------+--------+----------+-------+-------+
| id | name   | gender | birthday   | dept   | job      | sal   | bonus |
+----+--------+--------+------------+--------+----------+-------+-------+
|  1 | 王海涛 | 男     | 1995-03-25 | 培优部 | 金牌讲师 |  1800 |   300 |
|  2 | 齐雷   | 男     | 1994-04-06 | 培优部 | 金牌讲师 |  2500 |   600 |
|  3 | 刘沛霞 | 女     | 1996-06-14 | 培优部 | 金牌讲师 |  1400 |   300 |
|  4 | 陈子枢 | 男     | 1991-05-18 | 培优部 | 部门总监 |  4200 |   500 |
|  5 | 刘昱江 | 男     | 1993-02-18 | 培优部 | 金牌讲师 |  1600 |   500 |
|  6 | 王克晶 | 女     | 1998-07-18 | 就业部 | 金牌讲师 |  3700 |   600 |
|  7 | 苍老师 | 男     | 1995-08-18 | 就业部 | 部门总监 |  4850 |   400 |
|  8 | 范传奇 | 男     | 1999-03-18 | 就业部 | 金牌讲师 |  3200 |   600 |
|  9 | 刘涛   | 男     | 1990-04-18 | 就业部 | 金牌讲师 |  2700 |   400 |
| 10 | 韩少云 | 男     | 1980-05-18 | NULL   | CEO      | 50000 |  NULL |
+----+--------+--------+------------+--------+----------+-------+-------+
10 rows in set (0.000 sec)






-- ******** 基础查询 ********
-- 15.查询emp表中的所有员工，显示姓名，薪资，奖金
	select name,sal,bonus from emp;
结果如下：
+--------+-------+-------+
| name   | sal   | bonus |
+--------+-------+-------+
| 王海涛 |  1800 |   300 |
| 齐雷   |  2500 |   600 |
| 刘沛霞 |  1400 |   300 |
| 陈子枢 |  4200 |   500 |
| 刘昱江 |  1600 |   500 |
| 王克晶 |  3700 |   600 |
| 苍老师 |  4850 |   400 |
| 范传奇 |  3200 |   600 |
| 刘涛   |  2700 |   400 |
| 韩少云 | 50000 |  NULL |
+--------+-------+-------+
10 rows in set (0.000 sec)


	
-- 16.查询emp表中的所有员工，显示所有列
	select * from emp;

	/* 使用 *（星号）的缺点：把不必要的列也查询出来了，而且效率不如直接指定列名 */
    
+----+--------+--------+------------+--------+----------+-------+-------+
| id | name   | gender | birthday   | dept   | job      | sal   | bonus |
+----+--------+--------+------------+--------+----------+-------+-------+
|  1 | 王海涛 | 男     | 1995-03-25 | 培优部 | 金牌讲师 |  1800 |   300 |
|  2 | 齐雷   | 男     | 1994-04-06 | 培优部 | 金牌讲师 |  2500 |   600 |
|  3 | 刘沛霞 | 女     | 1996-06-14 | 培优部 | 金牌讲师 |  1400 |   300 |
|  4 | 陈子枢 | 男     | 1991-05-18 | 培优部 | 部门总监 |  4200 |   500 |
|  5 | 刘昱江 | 男     | 1993-02-18 | 培优部 | 金牌讲师 |  1600 |   500 |
|  6 | 王克晶 | 女     | 1998-07-18 | 就业部 | 金牌讲师 |  3700 |   600 |
|  7 | 苍老师 | 男     | 1995-08-18 | 就业部 | 部门总监 |  4850 |   400 |
|  8 | 范传奇 | 男     | 1999-03-18 | 就业部 | 金牌讲师 |  3200 |   600 |
|  9 | 刘涛   | 男     | 1990-04-18 | 就业部 | 金牌讲师 |  2700 |   400 |
| 10 | 韩少云 | 男     | 1980-05-18 | NULL   | CEO      | 50000 |  NULL |
+----+--------+--------+------------+--------+----------+-------+-------+
10 rows in set (0.000 sec)








-- 17.查询emp表中的所有部门和职位
	select dept, job from emp;
结果如下：
+--------+----------+
| dept   | job      |
+--------+----------+
| 培优部 | 金牌讲师 |
| 培优部 | 金牌讲师 |
| 培优部 | 金牌讲师 |
| 培优部 | 部门总监 |
| 培优部 | 金牌讲师 |
| 就业部 | 金牌讲师 |
| 就业部 | 部门总监 |
| 就业部 | 金牌讲师 |
| 就业部 | 金牌讲师 |
| NULL   | CEO      |
+--------+----------+
10 rows in set (0.000 sec)

	/* 思考：如果查询的结果中，存在大量重复的记录，如何剔除重复记录，只保留一条？ */
	select distinct dept, job from emp;
	-- distinct 用于剔除重复的记录
结果如下：
+--------+----------+
| dept   | job      |
+--------+----------+
| 培优部 | 金牌讲师 |
| 培优部 | 部门总监 |
| 就业部 | 金牌讲师 |
| 就业部 | 部门总监 |
| NULL   | CEO      |
+--------+----------+
5 rows in set (0.000 sec)





-- ******** WHERE子句查询 ********
-- 18.查询emp表中薪资大于3000的所有员工，显示员工姓名、薪资
   语法如下:
	select name,sal from emp
	where sal>3000;
	
结果如下：
+--------+-----------+
| name   | sal+bonus |
+--------+-----------+
| 陈子枢 |      4700 |
| 王克晶 |      4300 |
| 苍老师 |      5250 |
| 范传奇 |      3800 |
+--------+-----------+



	
-- 19.查询emp表中总薪资(薪资+奖金)大于3500的所有员工，显示员工姓名、总薪资

语法如下：

	    select name,sal+bonus from emp
	    where sal+bonus>3500;##结果有偏差也就是说任何和null相加的数字都是null
	
+--------+-----------+
| name   | sal+bonus |
+--------+-----------+
| 陈子枢 |      4700 |
| 王克晶 |      4300 |
| 苍老师 |      5250 |
| 范传奇 |      3800 |
+--------+-----------+
4 rows in set (0.000 sec)

优化办法
	      加入一个指令-- ifnull(指定的某个列, 指定变为什么值)函数: 判断指定的列（）是否包含null值, 如果有null值, 用第二个值替换null值，ifnull(bonus,0)意思是将   bonus中的null替换为0
	        
语法结构如下：
	          select name,sal+ifnull(bonus,0) from emp
	          where sal+ifnull(bonus,0)>3500;
结果如下：
+--------+---------------------+
| name   | sal+ifnull(bonus,0) |
+--------+---------------------+
| 陈子枢 |                4700 |
| 王克晶 |                4300 |
| 苍老师 |                5250 |
| 范传奇 |                3800 |
| 韩少云 |               50000 |
+--------+---------------------+
5 rows in set (0.018 sec)

	          
	/* 
	注意查看上面查询结果中的表头，思考如何将表头中的 name   修改为 姓名,  将sal+bonus 修改为 "总薪资" 
	*/
	
	select name as 姓名,sal+ifnull(bonus,0) as 总薪资 from emp
	where sal+ifnull(bonus,0)>3500;
结果如下：
+--------+--------+
| 姓名   | 总薪资 |
+--------+--------+
| 陈子枢 |   4700 |
| 王克晶 |   4300 |
| 苍老师 |   5250 |
| 范传奇 |   3800 |
| 韩少云 |  50000 |
+--------+--------+
5 rows in set (0.000 sec)

以上语法也可以省下as
将两个名字改了：一个name   一个sal+ifnull(bonus,0) 
	select name 姓名,sal+ifnull(bonus,0) 总薪资 from emp
	where sal+ifnull(bonus,0)>3500;
	------------------------------


	/* 试一试：where中能使用定义好的别名吗？ */
	
     提示：where  子句中不能使用定义好的别名（但是可以使用表别名）


如法如下：select  e.name,e.sal    from   emp  e 
               where   e.sal>3000;--这种用表命名的语法也正确
结果如下L：              
+--------+-------+
| name   | sal   |
+--------+-------+
| 陈子枢 |  4200 |
| 王克晶 |  3700 |
| 苍老师 |  4850 |
| 范传奇 |  3200 |
| 韩少云 | 50000 |
+--------+-------+
5 rows in set (0.000 sec)



	

-- 20.查询emp表中薪资在3000和4500之间的员工，显示员工姓名和薪资

语法如下：
（1）
	select name, sal from emp
	where sal>=3000 and sal<=4500;
+--------+------+
| name   | sal  |
+--------+------+
| 陈子枢 | 4200 |
| 王克晶 | 3700 |
| 范传奇 | 3200 |
+--------+------+
3 rows in set (0.000 sec)


	
	
	-- 或
（2）
	select name, sal from emp
	where sal between 3000 and 4500;
	
	/* 提示: between...and...：在...之间 */
结果如下”：
+--------+------+
| name   | sal  |
+--------+------+
| 陈子枢 | 4200 |
| 王克晶 | 3700 |
| 范传奇 | 3200 |
+--------+------+
3 rows in set (0.000 sec)



	
-- 21.查询emp表中薪资为 1400、1600、1800的员工，显示员工姓名和薪资
语法如下：
（1）
	select name, sal from emp
	where sal=1400 or sal=1600 or sal=1800;
+--------+------+
| name   | sal  |
+--------+------+
| 王海涛 | 1800 |
| 刘沛霞 | 1400 |
| 刘昱江 | 1600 |
+--------+------+
3 rows in set (0.000 sec)

	
	-- 或

（2）	
	select name, sal from emp
	where sal in(1400,1600,1800);






	
-- 22.查询薪资不为1400、1600、1800的员工
语法如下：
	select name, sal from emp
	where not(sal=1400 or sal=1600 or sal=1800);
结果如下：
+--------+-------+
| name   | sal   |
+--------+-------+
| 齐雷   |  2500 |
| 陈子枢 |  4200 |
| 王克晶 |  3700 |
| 苍老师 |  4850 |
| 范传奇 |  3200 |
| 刘涛   |  2700 |
| 韩少云 | 50000 |
+--------+-------+
7 rows in set (0.000 sec)
	
	-- 或

	
语法如下：
	select name, sal from emp
	where sal not in(1400,1600,1800);
	
结果如下：	
+--------+-------+
| name   | sal   |
+--------+-------+
| 齐雷   |  2500 |
| 陈子枢 |  4200 |
| 王克晶 |  3700 |
| 苍老师 |  4850 |
| 范传奇 |  3200 |
| 刘涛   |  2700 |
| 韩少云 | 50000 |
+--------+-------+
7 rows in set (0.001 sec)


	
-- 23.查询emp表中薪资大于4000和薪资小于2000的员工，显示员工姓名、薪资。
语法如下：
	select name,sal from emp
	where sal>4000 or sal<2000;
	
结果如下：
+--------+-------+
| name   | sal   |
+--------+-------+
| 王海涛 |  1800 |
| 刘沛霞 |  1400 |
| 陈子枢 |  4200 |
| 刘昱江 |  1600 |
| 苍老师 |  4850 |
| 韩少云 | 50000 |
+--------+-------+
6 rows in set (0.000 sec)



	
-- 24.查询emp表中薪资大于3000并且奖金小于600的员工，显示员工姓名、薪资、奖金。
语法如下：
	select name,sal,bonus from emp
	where sal>3000 and bonus<600;
结果如下：
+--------+------+-------+
| name   | sal  | bonus |
+--------+------+-------+
| 陈子枢 | 4200 |   500 |
| 苍老师 | 4850 |   400 |
+--------+------+-------+
2 rows in set (0.000 sec)


	-- 处理null值
	
	select name,sal,bonus from emp
	where sal>3000 and ifnull(bonus,0)<600;
结果如下：
+--------+-------+------------------+
| name   | sal   | ifnull( bonus,0) |
+--------+-------+------------------+
| 陈子枢 |  4200 |              500 |
| 苍老师 |  4850 |              400 |
| 韩少云 | 50000 |                0 |
+--------+-------+------------------+
3 rows in set (0.000 sec)






-- 25.查询没有部门的员工（即部门列为null值）
语法如下：
	select * from emp
	where dept is null;
结果如下：
+----+--------+--------+------------+------+------+-------+-------+
| id | name   | gender | birthday   | dept | job  | sal   | bonus |
+----+--------+--------+------------+------+------+-------+-------+
| 10 | 韩少云 | 男     | 1980-05-18 | NULL | CEO  | 50000 |  NULL |
+----+--------+--------+------------+------+------+-------+-------+
1 row in set (0.000 sec)

但是  
这个 select   name    from   emp       
           where   dept   is  null;
结果如下：
+--------+
| name   |
+--------+
| 韩少云 |
+--------+
1 row in set (0.000 sec)  

	
	-- 注意：null值不可以和其他值做运算


	
	/* 思考：如何查询有部门的员工（即部门列不为null值） */
语法如下：
 select * from emp
	where dept is not null;
结果如下：
+----+--------+--------+------------+--------+----------+------+-------+
| id | name   | gender | birthday   | dept   | job      | sal  | bonus |
+----+--------+--------+------------+--------+----------+------+-------+
|  1 | 王海涛 | 男     | 1995-03-25 | 培优部 | 金牌讲师 | 1800 |   300 |
|  2 | 齐雷   | 男     | 1994-04-06 | 培优部 | 金牌讲师 | 2500 |   600 |
|  3 | 刘沛霞 | 女     | 1996-06-14 | 培优部 | 金牌讲师 | 1400 |   300 |
|  4 | 陈子枢 | 男     | 1991-05-18 | 培优部 | 部门总监 | 4200 |   500 |
|  5 | 刘昱江 | 男     | 1993-02-18 | 培优部 | 金牌讲师 | 1600 |   500 |
|  6 | 王克晶 | 女     | 1998-07-18 | 就业部 | 金牌讲师 | 3700 |   600 |
|  7 | 苍老师 | 男     | 1995-08-18 | 就业部 | 部门总监 | 4850 |   400 |
|  8 | 范传奇 | 男     | 1999-03-18 | 就业部 | 金牌讲师 | 3200 |   600 |
|  9 | 刘涛   | 男     | 1990-04-18 | 就业部 | 金牌讲师 | 2700 |   400 |
+----+--------+--------+------------+--------+----------+------+-------+
9 rows in set (0.000 sec)

但是还可以这样玩

     select   name    from   emp       
        where   dept   is  not  null;
结果是这样的
+--------+
| name   |
+--------+
| 王海涛 |
| 齐雷   |
| 刘沛霞 |
| 陈子枢 |
| 刘昱江 |
| 王克晶 |
| 苍老师 |
| 范传奇 |
| 刘涛   |
+--------+
9 rows in set (0.000 sec)



-- ******** Like模糊查询 ********
-- 26.查询emp表中姓名中以"刘"开头的员工，显示员工姓名。
语法如下
	select name from emp
	where name  like '刘%';
	注意这里有格式
	/* like进行模糊查询，"%" 表示通配，表示0或多个字符。"_"表示一个任意的字符
	 ##百分号可以统配0或多个任意的字符*/

结果如下：
+--------+
| name   |
+--------+
| 刘沛霞 |
| 刘昱江 |
| 刘涛   |
+--------+
3 rows in set (0.004 sec)
	

	
-- 27.查询emp表中姓名中包含"涛"员工，显示员工姓名。

	select name from emp
	where name like '%涛%';##这种查询是将所有带涛的名字查询出
+--------+
| name   |
+--------+
| 王海涛 |
| 刘涛   |
+--------+
2 rows in set (0.000 sec)
     



	
-- 28.查询emp表中姓名以"刘"开头并且姓名为2个字的员工，显示员工姓名。

语法如下：
select name from emp
where name like '刘_';
结果如下：
+------+
| name |
+------+
| 刘涛 |
+------+
1 row in set (0.000 sec)


注意  /*__ 这个下划线表示一个任意字符运行结果会出现一个  如果是两个下划线就是两个任意字符___     */
	
	select name from emp

	where name like '刘__';
+--------+
| name   |
+--------+
| 刘沛霞 |
| 刘昱江 |
+--------+
2 rows in set (0.000 sec)



	
-- -----------------------------------
-- 三、分组查询、聚合函数、排序查询
-- -----------------------------------
-- 29.对emp表按照部门对员工进行分组，查看分组后效果
	/* 分组的语法: 
	select 查询的列 from 表名 group by 列名 
	根据指定的列进行分组 */


	按照以下要求分组：
	select id,name,dept from emp
	group by dept;
结果如下：
+----+--------+--------+
| id | name   | dept   |
+----+--------+--------+
| 10 | 韩少云 | NULL   |
|  1 | 王海涛 | 培优部 |
|  6 | 王克晶 | 就业部 |
+----+--------+--------+
3 rows in set (0.000 sec)




      select * from  emp    ##表示查所有员工
+----+--------+--------+------------+--------+----------+-------+-------+
| id | name   | gender | birthday   | dept   | job      | sal   | bonus |
+----+--------+--------+------------+--------+----------+-------+-------+
|  1 | 王海涛 | 男     | 1995-03-25 | 培优部 | 金牌讲师 |  1800 |   300 |
|  2 | 齐雷   | 男     | 1994-04-06 | 培优部 | 金牌讲师 |  2500 |   600 |
|  3 | 刘沛霞 | 女     | 1996-06-14 | 培优部 | 金牌讲师 |  1400 |   300 |
|  4 | 陈子枢 | 男     | 1991-05-18 | 培优部 | 部门总监 |  4200 |   500 |
|  5 | 刘昱江 | 男     | 1993-02-18 | 培优部 | 金牌讲师 |  1600 |   500 |
|  6 | 王克晶 | 女     | 1998-07-18 | 就业部 | 金牌讲师 |  3700 |   600 |
|  7 | 苍老师 | 男     | 1995-08-18 | 就业部 | 部门总监 |  4850 |   400 |
|  8 | 范传奇 | 男     | 1999-03-18 | 就业部 | 金牌讲师 |  3200 |   600 |
|  9 | 刘涛   | 男     | 1990-04-18 | 就业部 | 金牌讲师 |  2700 |   400 |
| 10 | 韩少云 | 男     | 1980-05-18 | NULL   | CEO      | 50000 |  NULL |
+----+--------+--------+------------+--------+----------+-------+-------+
10 rows in set (0.000 sec)


按部门进行分分组（所有相同的员工则为一组）
      select   name,dept from emp   group  by dept;
+--------+--------+
| name   | dept   |
+--------+--------+
| 韩少云 | NULL   |
| 王海涛 | 培优部 |
| 王克晶 | 就业部 |
+--------+--------+
3 rows in set (0.000 sec)


按部门进行分组，在统计每一组的员工数量
语法如下：
     select   count(*) from emp   group  by dept;
+----------+
| count(*) |
+----------+
|        1 |
|        5 |
|        4 |
+----------+
3 rows in set (0.000 sec)



	
	------------------------
	select count(id) from emp;
	select count(name) from emp;
	select count(*) from emp;
	------------------------

	
	-- 按照部门进行分组, 统计每个组(部门)的人数
	
	select dept,count(*) from emp
	group by dept;

+--------+----------+
| dept   | count(*) |
+--------+----------+
| NULL   |        1 |
| 培优部 |        5 |
| 就业部 |        4 |
+--------+----------+
3 rows in set (0.000 sec)




   select id,name,dept from emp
   group by dept;
+----+--------+--------+
| id | name   | dept   |
+----+--------+--------+
| 10 | 韩少云 | NULL   |
|  1 | 王海涛 | 培优部 |
|  6 | 王克晶 | 就业部 |
+----+--------+--------+
3 rows in set (0.000 sec)






-- 30.对emp表按照职位进行分组, 并统计每个职位的人数, 显示职位和对应人数

	select job,count(*) from emp
	group by job;
+----------+----------+
| job      | count(*) |
+----------+----------+
| CEO      |        1 |
| 部门总监 |        2 |
| 金牌讲师 |        7 |
+----------+----------+
3 rows in set (0.000 sec)






	
-- 31.对emp表按照部门进行分组, 求每个部门的最高薪资(不包含奖金)，显示部门名称和最高薪资
	--（1） 统计员工表中的最高薪资
	
	select max(sal) from emp;
结果如下：
+----------+
| max(sal) |
+----------+
|    50000 |
+----------+
1 row in set (0.000 sec)


	
	-- （2）统计每个部门的最高薪资
	
	select dept, max(sal) from emp
	group by dept;
结果如下：
+--------+----------+
| dept   | max(sal) |
+--------+----------+
| NULL   |    50000 |
| 培优部 |     4200 |
| 就业部 |     4850 |
+--------+----------+
3 rows in set (0.000 sec)
	
	-- （3）统计每个职位的最高薪资
	select job, max(sal) from emp
	group by job;

结果如下：

+----------+----------+
| job      | max(sal) |
+----------+----------+
| CEO      |    50000 |
| 部门总监 |     4850 |
| 金牌讲师 |     3700 |
+----------+----------+
3 rows in set (0.000 sec)



-- 32.统计emp表中薪资大于3000的员工个数（- count(column)统计某列的行数）


   select count(sal) from emp
	where sal>3000; ##统计行数
+-----------+
| count(id) |
+-----------+
|         5 |
+-----------+
1 row in set (0.000 sec)

	select count(*) from emp
	where sal>3000; ##这是统计表中所有人员个数是一样的	
+----------+
| count(*) |
+----------+
|        5 |
+----------+
1 row in set (0.001 sec)
	-- 注意:聚合函数在统计时会自动剔除null值(即null不参与统计)




	
-- 33.统计emp表中所有员工的薪资总和(不包含奖金)（- sum(column)对某列的值求和）
	select sum(sal) from emp; 
	注意上面的语法有格式
+----------+
| sum(sal) |
+----------+
|    75950 |
+----------+
1 row in set (0.000 sec)




-- 34.统计emp表员工的平均薪资(不包含奖金)（- avg(column)对某列的值求平均值）

	select sum(sal)/count(*) from emp;
+-------------------+
| sum(sal)/count(*) |
+-------------------+
|              7595 |
+-------------------+
1 row in set (0.013 sec)





	select avg(sal) from emp;
+----------+
| avg(sal) |
+----------+
|     7595 |
+----------+
1 row in set (0.001 sec)





-- 35.查询emp表中所有在1993和1995年之间出生的员工，显示姓名、出生日期。
	select name,birthday from emp
	where year(birthday)>=1993 
		and year(birthday)<=1995;
+--------+------------+
| name   | birthday   |
+--------+------------+
| 王海涛 | 1995-03-25 |
| 齐雷   | 1994-04-06 |
| 刘昱江 | 1993-02-18 |
| 苍老师 | 1995-08-18 |
+--------+------------+
4 rows in set (0.001 sec)




	
-- 36.查询本月过生日的所有员工
	select name,birthday from emp
	where month(curdate())=month(birthday);
	 -- month(curdate()) 获取当前月份
	-- month(birthday) 获取员工出生的月份
	
	/* 
	curdate() 获取当前日期 年月日
	curtime() 获取当前时间 时分秒
	sysdate() 获取当前日期+时间 年月日 时分秒 */

	
（1）
MariaDB [db10]> select  curdate();
+------------+
| curdate()  |
+------------+
| 2019-07-01 |
+------------+
1 row in set (0.000 sec)

（2）
统计本月七月过生日的人
语法如下;
select name,birthday from emp
	where month(curdate())=month(birthday);
结果如下：
MariaDB [db10]> select name,birthday from emp
   where month(curdate())=month(birthday);
+--------+------------+
| name   | birthday   |
+--------+------------+
| 王克晶 | 1998-07-18 |
+--------+------------+
1 row in set (0.000 sec)

（2）
MariaDB [db10]> select  month(curdate());
+------------------+
| month(curdate()) |
+------------------+
|                7 |
+------------------+
1 row in set (0.000 sec)
（3）
在七月基础上显示出八月谁过生日
语法如下：
  select name,birthday from emp
      where month(curdate())+1=month(birthday);
运行结果：
MariaDB [db10]> select name,birthday from emp
   where month(curdate())+1=month(birthday);
+--------+------------+
| name   | birthday   |
+--------+------------+
| 苍老师 | 1995-08-18 |
+--------+------------+
1 row in set (0.000 sec)



-- 查询系统当前时间。
select now();

+---------------------+
| now()               |
+---------------------+
| 2019-07-01 15:27:43 |
+---------------------+
1 row in set (0.000 sec)





-- 查询emp表中所有员工的年龄，显示姓名、年龄。
select name,year(curdate()) - year(birthday) 年龄 from emp;
结果如下：
+--------+------+
| name   | 年龄 |
+--------+------+
| 王海涛 |   24 |
| 齐雷   |   25 |
| 刘沛霞 |   23 |
| 陈子枢 |   28 |
| 刘昱江 |   26 |
| 王克晶 |   21 |
| 苍老师 |   24 |
| 范传奇 |   20 |
| 刘涛   |   29 |
| 韩少云 |   39 |
+--------+------+
10 rows in set (0.000 sec)




-- 查询emp表中所有在1993和1995年出生的，显示姓名、出生日期。
select name,birthday from emp where year(birthday) between 1993 and 1995;

+--------+------------+
| name   | birthday   |
+--------+------------+
| 王海涛 | 1995-03-25 |
| 齐雷   | 1994-04-06 |
| 刘昱江 | 1993-02-18 |
| 苍老师 | 1995-08-18 |
+--------+------------+
4 rows in set (0.000 sec)









-- ----------------------------------------------------------------------------
-- ************************************* 排序查询 *******************************
-- ----------------------------------------------------------------------------


-- 37.对emp表中所有员工的薪资进行升序(从低到高)排序，显示员工姓名、薪资。

      /*  
      order by 排序的列 asc 升序(从低到高)
		order by 排序的列 desc 降序(从高到低) */

		
select name, sal from emp;
+--------+------+
| name   | sal  |
+--------+------+
| 王海涛 | 1800 |
| 齐雷   | 2500 |
| 刘沛霞 | 1400 |
| 陈子枢 | 4200 |
| 刘昱江 | 1600 |
| 王克晶 | 3700 |
| 苍老师 | 4850 |
| 范传奇 | 3200 |
| 刘涛   | 2700 |
| 韩少云 | 5000 |
+--------+------+
10 rows in set (0.000 sec)


	



（1）
查sal按照升序
	select name, sal from emp
	order by sal asc;
+--------+------+
| name   | sal  |
+--------+------+
| 刘沛霞 | 1400 |
| 刘昱江 | 1600 |
| 王海涛 | 1800 |
| 齐雷   | 2500 |
| 刘涛   | 2700 |
| 范传奇 | 3200 |
| 王克晶 | 3700 |
| 陈子枢 | 4200 |
| 苍老师 | 4850 |
| 韩少云 | 5000 |
+--------+------+
10 rows in set (0.000 sec)


（2）
默认查sal就是升序
	select name, sal from emp
	order by sal ;
	/* 默认就是升序，所以asc可以省略不写 */
+--------+------+
| name   | sal  |
+--------+------+
| 刘沛霞 | 1400 |
| 刘昱江 | 1600 |
| 王海涛 | 1800 |
| 齐雷   | 2500 |
| 刘涛   | 2700 |
| 范传奇 | 3200 |
| 王克晶 | 3700 |
| 陈子枢 | 4200 |
| 苍老师 | 4850 |
| 韩少云 | 5000 |
+--------+------+
10 rows in set (0.000 sec)


（3）降序排sal
 select name, sal from emp
    -> order by       sal         desc;
+--------+------+
| name   | sal  |
+--------+------+
| 韩少云 | 5000 |
| 苍老师 | 4850 |
| 陈子枢 | 4200 |
| 王克晶 | 3700 |
| 范传奇 | 3200 |
| 刘涛   | 2700 |
| 齐雷   | 2500 |
| 王海涛 | 1800 |
| 刘昱江 | 1600 |
| 刘沛霞 | 1400 |
+--------+------+
10 rows in set (0.000 sec)



-- 38.对emp表中所有员工奖金进行降序(从高到低)排序，显示员工姓名、奖金。
	select name, bonus from emp
	order by bonus desc;
	
	select name, birthday from emp
	order by birthday asc;







	
-- -----------------------------------
-- **************** 分页查询 ***************
-- -----------------------------------

	规则如下;
	/*	在mysql中，通过limit进行分页查询：
	语法如下：
             select  *   from   emp   limit   x,y;

		limit (页码-1)*每页显示记录数, 每页显示记录数
     注意：          x表示   （你准备分几页-1）*每一页显示几行
                     y表示每一页显示几行
		 */

		 
x表示：(页码-1)*每页显示记录数
y表示每页显示的记录数。

		
-- 39.查询emp表中的所有记录，分页显示：每页显示3条记录，返回第 1 页。

	-- 第 1 页
	select * from emp limit 0, 3;
结果如下：
MariaDB [db10]> -- 第 1 页
MariaDB [db10]> select * from emp limit 0, 3;
+----+--------+--------+------------+--------+----------+------+-------+
| id | name   | gender | birthday   | dept   | job      | sal  | bonus |
+----+--------+--------+------------+--------+----------+------+-------+
|  1 | 王海涛 | 男     | 1995-03-25 | 培优部 | 金牌讲师 | 1800 |   300 |
|  2 | 齐雷   | 男     | 1994-04-06 | 培优部 | 金牌讲师 | 2500 |   600 |
|  3 | 刘沛霞 | 女     | 1996-06-14 | 培优部 | 金牌讲师 | 1400 |   300 |
+----+--------+--------+------------+--------+----------+------+-------+

	-- 第 2 页
	select * from emp limit 3, 3;
结果如下：
MariaDB [db10]> -- 第 2 页
MariaDB [db10]> select * from emp limit 3, 3;
+----+--------+--------+------------+--------+----------+------+-------+
| id | name   | gender | birthday   | dept   | job      | sal  | bonus |
+----+--------+--------+------------+--------+----------+------+-------+
|  4 | 陈子枢 | 男     | 1991-05-18 | 培优部 | 部门总监 | 4200 |   500 |
|  5 | 刘昱江 | 男     | 1993-02-18 | 培优部 | 金牌讲师 | 1600 |   500 |
|  6 | 王克晶 | 女     | 1998-07-18 | 就业部 | 金牌讲师 | 3700 |   600 |
+----+--------+--------+------------+--------+----------+------+-------+
3 rows in set (0.001 sec)

	-- 第 3 页
	select * from emp limit 6, 3;
结果如下：
MariaDB [db10]> -- 第 3 页
MariaDB [db10]> select * from emp limit 6, 3;
+----+--------+--------+------------+--------+----------+------+-------+
| id | name   | gender | birthday   | dept   | job      | sal  | bonus |
+----+--------+--------+------------+--------+----------+------+-------+
|  7 | 苍老师 | 男     | 1995-08-18 | 就业部 | 部门总监 | 4850 |   400 |
|  8 | 范传奇 | 男     | 1999-03-18 | 就业部 | 金牌讲师 | 3200 |   600 |
|  9 | 刘涛   | 男     | 1990-04-18 | 就业部 | 金牌讲师 | 2700 |   400 |
+----+--------+--------+------------+--------+----------+------+-------+
3 rows in set (0.000 sec)
	

	-- 第 4 页
	select * from emp limit 9, 3;
结果如下
MariaDB [db10]> -- 第 4 页
MariaDB [db10]> select * from emp limit 9, 3;
+----+--------+--------+------------+------+------+-------+-------+
| id | name   | gender | birthday   | dept | job  | sal   | bonus |
+----+--------+--------+------------+------+------+-------+-------+
| 10 | 韩少云 | 男     | 1980-05-18 | NULL | CEO  | 50000 |  NULL |
+----+--------+--------+------------+------+------+-------+-------+
1 row in set (0.000 sec



	
	
-- 40.查询emp表中的所有记录，分页显示：每页显示3条记录，返回第 2 页。
	select * from emp limit 3, 3;



	
-- -----------------------------------
-- 三、外键
-- -----------------------------------
-- 准备数据： 以下练习将使用db20库中的表及表记录，请先进入db20数据库!!!
-- 准备数据： 以下练习将使用db20库中的表及表记录，请先进入db20数据库!!!
-- 41.尝试删除dept表中的某一个部门


	
	/*上面的部门删除成功后，员工表里的某些员工就没有了对应的部门,
	这种我们称之为数据的完整性被破坏了,
	为了避免这种情况，可以在删除之前，查看将要删除的部门下是否还有员工存在，如果有就不要删除;
	或者，让数据库帮我们去维护这样的对应关系，也就是当将要被删除的部门下如果还有员工，
	就阻止删除操作，让数据库帮我们维护这样的对应关系，就需要指定外键。 */




-- 42.重新创建db20中的dept和emp表，在创建时，指定emp表中的dept_id列为外键，即这一列要严格参考dept表中的id列, 再次尝试删除dept表中的某一个部门，查看是否能删除成功





	
-- -----------------------------------
-- 四、关联查询、外连接查询
-- -----------------------------------
-- 准备数据： 以下练习将使用db30库中的表及表记录，请先进入db30数据库!!!
-- 准备数据： 以下练习将使用db30库中的表及表记录，请先进入db30数据库!!!





-- 43.查询部门和部门对应的员工信息
以下叫关联查询
（1）
	select * from dept,emp
	where dept_id=dept.id;
+----+--------+----+------+---------+
| id | name   | id | name | dept_id |
+----+--------+----+------+---------+
|  1 | 财务部 |  1 | 张三 |       1 |
|  2 | 人事部 |  2 | 李四 |       2 |
|  3 | 科技部 |  3 | 老王 |       3 |
+----+--------+----+------+---------+
3 rows in set (0.000 sec)
这样会有大量的错误数据

关于关联查询的
	select * from dept   ,    emp
	where emp.dept_id=dept.id;
+----+--------+----+------+---------+
| id | name   | id | name | dept_id |
+----+--------+----+------+---------+
|  1 | 财务部 |  1 | 张三 |       1 |
|  2 | 人事部 |  2 | 李四 |       2 |
|  3 | 科技部 |  3 | 老王 |       3 |
+----+--------+----+------+---------+
3 rows in set (0.000 sec)





（1）
右外链接：
	select * from emp right join dept 
	  on emp.dept_id=dept.id;
+------+------+---------+----+--------+
| id   | name | dept_id | id | name   |
+------+------+---------+----+--------+
|    1 | 张三 |       1 |  1 | 财务部 |
|    2 | 李四 |       2 |  2 | 人事部 |
|    3 | 老王 |       3 |  3 | 科技部 |
| NULL | NULL |    NULL |  4 | 销售部 |
+------+------+---------+----+--------+
4 rows in set (0.000 sec)

（2）
左外链接：
	 select *  from dept  left    join    
	  emp    on  dept_id =   dept.id;
+----+--------+------+------+---------+
| id | name   | id   | name | dept_id |
+----+--------+------+------+---------+
|  1 | 财务部 |    1 | 张三 |       1 |
|  2 | 人事部 |    2 | 李四 |       2 |
|  3 | 科技部 |    3 | 老王 |       3 |
|  4 | 销售部 | NULL | NULL |    NULL |
+----+--------+------+------+---------+
4 rows in set (0.000 sec)




-- 45.查询部门和所有员工，如果员工没有所属部门，部门显示为null

	select * from emp left join dept 
	on emp.dept_id=dept.id;
	
+----+------+---------+------+--------+
| id | name | dept_id | id   | name   |
+----+------+---------+------+--------+
|  1 | 张三 |       1 |    1 | 财务部 |
|  2 | 李四 |       2 |    2 | 人事部 |
|  3 | 老王 |       3 |    3 | 科技部 |
|  4 | 赵六 |       5 | NULL | NULL   |
+----+------+---------+------+--------+
4 rows in set (0.000 sec)







-- -----------------------------------
-- 五、子查询、多表查询
-- -----------------------------------
-- 准备数据：以下练习将使用db40库中的表及表记录，请先进入db40数据库!!!
-- 准备数据：以下练习将使用db40库中的表及表记录，请先进入db40数据库!!!

以下是子查询：（一个表命令里嵌套了一个命令）

-- 46.列出薪资比'王海涛'薪资高的所有员工，显示姓名、薪资
	-- 假设'王海涛'的薪资为2500,求出薪资比2500高的所有员工
	select name,sal
	from emp
	where sal>2500;
+------+--------+
| sal  | name   |
+------+--------+
| 3675 | 刘苍松 |
| 3450 | 陈子枢 |
| 3000 | 程祖红 |
| 5000 | 韩少云 |
| 3000 | 朴乾   |
+------+--------+
5 rows in set (0.000 sec)


	-- 求出'王海涛'的薪资是多少
	select sal from emp where name='王海涛';

+------+
| sal  |
+------+
| 2450 |
+------+
1 row in set (0.000 sec)
	
	-- 合并两条sql语句
	select name,sal
	from emp
	where sal>( select sal from emp where name='王海涛' );


	
	-- 求出'刘沛霞'的职位
	select job from emp where name='刘沛霞';


	
	-- 合并两条sql语句
	select name, job, dept_id from emp
	where job=(select job from emp where name='刘沛霞');
+--------+--------+---------+
| name   | job    | dept_id |
+--------+--------+---------+
| 王海涛 | 推销员 |      10 |
| 张慎政 | 推销员 |      10 |
| 刘沛霞 | 推销员 |      10 |
+--------+--------+---------+
3 rows in set (0.000 sec)


-- 48.列出薪资比'大数据部'部门(已知部门编号为30)所有员工薪资都高的员工信息，显示员工姓名、薪资和部门名称。
	-- 外连接查询, 查询所有员工和对应的部门
	select emp.name, sal, dept.name
	from emp left join dept
	on emp.dept_id=dept.id; 


	
	-- 假设大数据部门最高薪资为3000,求出薪资大于3000的所有员工
	select emp.name, sal, dept.name
	from emp left join dept
	on emp.dept_id=dept.id
	where sal > 3000;


	
	-- 求出大数据部门的最高薪资
	select max(sal) from emp where dept_id=30;
	-- 将最后上面两条sql语句合并在一起
	select emp.name, sal, dept.name
	from emp left join dept
	on emp.dept_id=dept.id
	where sal > (select max(sal) from emp where dept_id=30);

-- 49.列出在'培优部'任职的员工，假定不知道'培优部'的部门编号， 显示部门名称，员工名称。
	-- 关联查询两张表
	select dept.name, emp.name
	from emp,dept
	where emp.dept_id=dept.id;



	
	-- 求出在培优部的员工
	select dept.name, emp.name
	from emp,dept
	where emp.dept_id=dept.id
		and dept.name='培优部';


		

-- 50.(自查询)列出所有员工及其直接上级，显示员工姓名、上级编号，上级姓名
	/*
	显示的列: e1.name, e2.id, e2.name
	查询的表: 	emp e1 员工表
			emp e2 上级表
	关联关系: e1.topid=e2.id */
	
	select e1.name, e2.id, e2.name
	from emp e1, emp e2
	where e1.topid=e2.id;



	
-- 51.列出最低薪资大于1500的各种职位，显示职位和该职位最低薪资
	-- 求出每个职位的最低薪资
	select job, min(sal) from emp group by job;
	
	-- 求出最低薪资大于1500的职位
	select job, min(sal) from emp 
	group by job
	having min(sal)>1500;
	------------------------

	
	select job, min(sal) from emp 
	where min(sal)
	group by job;##错误!




-- 52.列出在每个部门就职的员工数量、平均工资。显示部门编号、员工数量，平均薪资。
	select dept_id, count(*), avg(sal)
	from emp
	group by dept_id;




	
-- 53.查出至少有一个员工的部门。显示部门编号、部门名称、部门位置、部门人数。
	-- 关联查询两张表(dept, emp),根据部门进行分组, 并统计部门人数
	select d.id, d.name, loc, count(*)
	from dept d, emp e
	where d.id=e.dept_id
	group by d.name;
	



	
-- 54.列出受雇日期早于直接上级的所有员工的编号、姓名、部门名称。
	/* -- emp e1 员工表  
	-- emp e2 上级表
	列: e1.id, e1.name, d.name
	表: emp e1,emp e2, dept d
	关联条件:
		e1.topid=e2.id
		e1.dept_id=d.id
	筛选条件:
		e1.hdate<e2.hdate
	 */
	select e1.id, e1.name, d.name
	from emp e1,emp e2, dept d
	where e1.topid=e2.id 
		and e1.dept_id=d.id
		and e1.hdate<e2.hdate;




	
-- 55.列出每个部门薪资最高的员工信息，显示部门编号、员工姓名、薪资
	-- 查询emp表中每个部门的最高薪资，显示部门编号、最高薪资
	select dept_id,max(sal)
	from emp
	group by dept_id;
	-- 查询emp表中所有员工的部门编号、姓名、薪资
	select dept_id,name,sal
	from emp;
	-- 第一次查询的结果作为一张临时表和第二次查询进行关联查询
	select e.dept_id,t1.maxsal,name 
	from emp e,(select dept_id,max(sal) maxsal
	from emp
	group by dept_id) t1
	where e.dept_id=t1.dept_id
		and e.sal=t1.maxsal;
		
		
	
	





======================================
补充1、笛卡尔积查询：
	笛卡尔积查询：如果同时查询两张表，左边表有m条数据，右边表有n条数据，那么笛卡尔积查询是结果就是 m*n 条记录。这就是笛卡尔积查询。例如： 
语法：
	select * from dept,emp;
结果：
MariaDB [db30]> select   *  from   dept  ,  emp;
+----+--------+----+------+---------+
| id | name   | id | name | dept_id |
+----+--------+----+------+---------+
|  1 | 财务部 |  1 | 张三 |       1 |
|  2 | 人事部 |  1 | 张三 |       1 |
|  3 | 科技部 |  1 | 张三 |       1 |
|  4 | 销售部 |  1 | 张三 |       1 |
|  1 | 财务部 |  2 | 李四 |       2 |
|  2 | 人事部 |  2 | 李四 |       2 |
|  3 | 科技部 |  2 | 李四 |       2 |
|  4 | 销售部 |  2 | 李四 |       2 |
|  1 | 财务部 |  3 | 老王 |       3 |
|  2 | 人事部 |  3 | 老王 |       3 |
|  3 | 科技部 |  3 | 老王 |       3 |
|  4 | 销售部 |  3 | 老王 |       3 |
|  1 | 财务部 |  4 | 赵六 |       5 |
|  2 | 人事部 |  4 | 赵六 |       5 |
|  3 | 科技部 |  4 | 赵六 |       5 |
|  4 | 销售部 |  4 | 赵六 |       5 |
+----+--------+----+------+---------+
16 rows in set (0.000 sec)

	上面的查询中包含大量错误的数据, 一般不使用这种查询。
	
	如果只想保留正确的记录，可以通过where条件进行筛选，将符合条件的保留下来，不符合条件的自然就会被剔除，例如：
	select * from dept,emp
	where dept.id=emp.dept_id;
结果：
+----+--------+----+------+---------+
| id | name   | id | name | dept_id |
+----+--------+----+------+---------+
|  1 | 财务部 |  1 | 张三 |       1 |
|  2 | 人事部 |  2 | 李四 |       2 |
|  3 | 科技部 |  3 | 老王 |       3 |
+----+--------+----+------+---------+
3 rows in set (0.000 sec)


	

补充2、左外连接和右外连接查询：
	(1) 左外连接查询：是将左边表中所有数据都查询出来, 如果在右边表中没有对应的记录, 右边表显示为null即可。
	(2) 右外连接查询：是将右边表中所有数据都查询出来, 如果在左边表中没有对应的记录, 左边表显示为null即可。

补充3、where和having都用于筛选过滤，但是： 
	(1) where用于在分组之前进行筛选, having用于在分组之后进行筛选
	(2) 并且where中不能使用列别名, having中可以使用别名
	(3) where子句中不能使用列别名(可以使用表别名), 因为where子句比select先执行!!
	
补充4、SQL语句的书写顺序和执行顺序:
  SQL语句的书写顺序：
	select...
	from...
	where...
	group by...
	order by...
	...
  SQL语句的执行顺序：
	from... -- 确定要查询的是哪张表 (定义表别名)
	where... -- 从整张表的数据中进行筛选过滤
	select... -- 确定要显示哪些列 (定义列别名)
	group by... -- 根据指定的列进行分组
	order by... -- 根据指定的列进行排序
	...
======================================










